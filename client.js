/**
 * Discord Music Bot Client
 * 16-Bot System with 24/7 Operation and Slash Commands
 */

const { Client, GatewayIntentBits, EmbedBuilder, SlashCommandBuilder, REST, Routes, Collection } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, VoiceConnectionStatus, AudioPlayerStatus, getVoiceConnection } = require('@discordjs/voice');
const ytdl = require('ytdl-core');
const YouTubeSearchAPI = require('youtube-search-api');

class MusicBot {
    constructor(botNumber) {
        this.botNumber = botNumber;
        this.client = new Client({
            intents: [
                GatewayIntentBits.Guilds,
                GatewayIntentBits.GuildMessages,
                GatewayIntentBits.MessageContent,
                GatewayIntentBits.GuildVoiceStates
            ]
        });
        
        this.musicPlayers = new Collection();
        this.setupEventHandlers();
        this.setupSlashCommands();
    }

    setupEventHandlers() {
        this.client.once('ready', async () => {
            console.log(`‚úÖ Bot #${this.botNumber} (${this.client.user.tag}) is ready!`);
            console.log(`üìä Bot #${this.botNumber} is in ${this.client.guilds.cache.size} servers`);
            
            // Set bot activity
            this.client.user.setActivity(`üéµ Bot #${this.botNumber} | /help`, { type: 2 });
            
            // Sync slash commands
            await this.syncSlashCommands();
        });

        this.client.on('guildCreate', (guild) => {
            console.log(`üîó Bot #${this.botNumber} joined guild: ${guild.name}`);
        });

        this.client.on('guildDelete', (guild) => {
            console.log(`‚ùå Bot #${this.botNumber} left guild: ${guild.name}`);
            this.musicPlayers.delete(guild.id);
        });

        this.client.on('interactionCreate', async (interaction) => {
            if (!interaction.isChatInputCommand()) return;
            
            try {
                await this.handleSlashCommand(interaction);
            } catch (error) {
                console.error(`‚ùå Error handling command for Bot #${this.botNumber}:`, error);
                
                const errorEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('‚ùå Error')
                    .setDescription('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ£ŸÖÿ±!')
                    .setFooter({ text: `Bot #${this.botNumber}` });
                
                if (!interaction.replied) {
                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
                }
            }
        });
    }

    setupSlashCommands() {
        this.commands = [
            // Music Commands
            new SlashCommandBuilder()
                .setName('play')
                .setDescription('Play music from YouTube')
                .addStringOption(option =>
                    option.setName('query')
                        .setDescription('YouTube URL or search query')
                        .setRequired(true)
                ),
            
            new SlashCommandBuilder()
                .setName('pause')
                .setDescription('Pause current song'),
            
            new SlashCommandBuilder()
                .setName('resume')
                .setDescription('Resume paused song'),
            
            new SlashCommandBuilder()
                .setName('skip')
                .setDescription('Skip current song'),
            
            new SlashCommandBuilder()
                .setName('stop')
                .setDescription('Stop music and clear queue'),
            
            new SlashCommandBuilder()
                .setName('queue')
                .setDescription('Show music queue'),
            
            new SlashCommandBuilder()
                .setName('nowplaying')
                .setDescription('Show currently playing song'),
            
            new SlashCommandBuilder()
                .setName('volume')
                .setDescription('Set volume (0-100)')
                .addIntegerOption(option =>
                    option.setName('level')
                        .setDescription('Volume level (0-100)')
                        .setRequired(true)
                        .setMinValue(0)
                        .setMaxValue(100)
                ),
            
            // Voice Commands
            new SlashCommandBuilder()
                .setName('joinroom')
                .setDescription('Join a voice channel')
                .addStringOption(option =>
                    option.setName('channel_name')
                        .setDescription('Voice channel name')
                        .setRequired(true)
                ),
            
            new SlashCommandBuilder()
                .setName('leave')
                .setDescription('Leave current voice channel'),
            
            new SlashCommandBuilder()
                .setName('listrooms')
                .setDescription('List all voice channels'),
            
            // Bot Info Commands
            new SlashCommandBuilder()
                .setName('botinfo')
                .setDescription('Show bot information'),
            
            new SlashCommandBuilder()
                .setName('help')
                .setDescription('Show all available commands'),
            
            new SlashCommandBuilder()
                .setName('test')
                .setDescription('Test if slash commands work'),
            
            // Admin Commands
            new SlashCommandBuilder()
                .setName('admin_botlist')
                .setDescription('[ADMIN] List all active bots'),
            
            new SlashCommandBuilder()
                .setName('admin_moveall')
                .setDescription('[ADMIN] Move all bots to a channel')
                .addStringOption(option =>
                    option.setName('channel_name')
                        .setDescription('Voice channel name')
                        .setRequired(true)
                ),
            
            new SlashCommandBuilder()
                .setName('admin_disconnectall')
                .setDescription('[ADMIN] Disconnect all bots'),
            
            new SlashCommandBuilder()
                .setName('admin_forcejoin')
                .setDescription('[ADMIN] Force this bot to join channel')
                .addStringOption(option =>
                    option.setName('channel_name')
                        .setDescription('Voice channel name')
                        .setRequired(true)
                ),
            
            new SlashCommandBuilder()
                .setName('admin_status')
                .setDescription('[ADMIN] Show detailed bot status')
        ];
    }

    async syncSlashCommands() {
        try {
            const rest = new REST({ version: '10' }).setToken(this.client.token);
            
            const commandData = this.commands.map(command => command.toJSON());
            
            // Sync globally
            await rest.put(Routes.applicationCommands(this.client.user.id), {
                body: commandData
            });
            
            console.log(`üîÑ Bot #${this.botNumber}: Synced ${commandData.length} slash commands globally`);
            
            // Sync per guild
            for (const guild of this.client.guilds.cache.values()) {
                try {
                    await rest.put(Routes.applicationGuildCommands(this.client.user.id, guild.id), {
                        body: commandData
                    });
                    console.log(`üîÑ Bot #${this.botNumber}: Synced commands for guild ${guild.name}`);
                } catch (error) {
                    console.error(`‚ùå Bot #${this.botNumber}: Failed to sync for guild ${guild.name}:`, error.message);
                }
            }
        } catch (error) {
            console.error(`‚ùå Bot #${this.botNumber}: Failed to sync slash commands:`, error);
        }
    }

    getMusicPlayer(guildId) {
        if (!this.musicPlayers.has(guildId)) {
            this.musicPlayers.set(guildId, {
                queue: [],
                currentSong: null,
                connection: null,
                player: createAudioPlayer(),
                isPlaying: false,
                volume: 0.5,
                channel: null
            });
        }
        return this.musicPlayers.get(guildId);
    }

    async handleSlashCommand(interaction) {
        const { commandName } = interaction;
        
        switch (commandName) {
            case 'test':
                await interaction.reply({
                    content: `‚úÖ ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠!`,
                    ephemeral: true
                });
                break;
            
            case 'help':
                await this.handleHelpCommand(interaction);
                break;
            
            case 'play':
                await this.handlePlayCommand(interaction);
                break;
            
            case 'joinroom':
                await this.handleJoinRoomCommand(interaction);
                break;
            
            case 'leave':
                await this.handleLeaveCommand(interaction);
                break;
            
            case 'listrooms':
                await this.handleListRoomsCommand(interaction);
                break;
            
            case 'botinfo':
                await this.handleBotInfoCommand(interaction);
                break;
            
            case 'pause':
                await this.handlePauseCommand(interaction);
                break;
            
            case 'resume':
                await this.handleResumeCommand(interaction);
                break;
            
            case 'skip':
                await this.handleSkipCommand(interaction);
                break;
            
            case 'stop':
                await this.handleStopCommand(interaction);
                break;
            
            case 'queue':
                await this.handleQueueCommand(interaction);
                break;
            
            case 'nowplaying':
                await this.handleNowPlayingCommand(interaction);
                break;
            
            case 'volume':
                await this.handleVolumeCommand(interaction);
                break;
            
            // Admin Commands
            case 'admin_botlist':
                await this.handleAdminBotListCommand(interaction);
                break;
            
            case 'admin_status':
                await this.handleAdminStatusCommand(interaction);
                break;
            
            case 'admin_forcejoin':
                await this.handleAdminForceJoinCommand(interaction);
                break;
            
            default:
                await interaction.reply({
                    content: '‚ùå ÿ£ŸÖÿ± ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ!',
                    ephemeral: true
                });
        }
    }

    async handleHelpCommand(interaction) {
        const embed = new EmbedBuilder()
            .setColor('#0099FF')
            .setTitle(`üéµ Bot #${this.botNumber} - ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸàÿßŸÖÿ±`)
            .setDescription('ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:')
            .addFields(
                {
                    name: 'üéµ ÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ',
                    value: '`/play` - ÿ™ÿ¥ÿ∫ŸäŸÑ ŸÖŸàÿ≥ŸäŸÇŸâ ŸÖŸÜ ŸäŸàÿ™ŸäŸàÿ®\n`/pause` - ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™\n`/resume` - ÿßÿ≥ÿ™ŸÉŸÖÿßŸÑ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ\n`/skip` - ÿ™ÿÆÿ∑Ÿä ÿßŸÑÿ£ÿ∫ŸÜŸäÿ©\n`/stop` - ÿ•ŸäŸÇÿßŸÅ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©\n`/queue` - ÿπÿ±ÿ∂ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±\n`/nowplaying` - ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`/volume` - ÿ™ÿ∫ŸäŸäÿ± ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™',
                    inline: false
                },
                {
                    name: 'ü§ñ ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ',
                    value: '`/joinroom` - ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑÿ∫ÿ±ŸÅÿ© ÿµŸàÿ™Ÿäÿ©\n`/leave` - ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©\n`/listrooms` - ÿπÿ±ÿ∂ ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿµŸàÿ™Ÿäÿ©\n`/botinfo` - ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ®Ÿàÿ™',
                    inline: false
                }
            )
            .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} ‚Ä¢ ŸäÿπŸÖŸÑ 24/7 ‚Ä¢ ÿßÿ≥ÿ™ÿÆÿØŸÖ / ŸÑÿ±ÿ§Ÿäÿ© ÿßŸÑÿ£ŸàÿßŸÖÿ±` });
        
        if (interaction.memberPermissions?.has('Administrator')) {
            embed.addFields({
                name: 'üîß ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ•ÿØÿßÿ±ÿ©',
                value: '`/admin_botlist` - ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™\n`/admin_status` - ÿ≠ÿßŸÑÿ© ÿ™ŸÅÿµŸäŸÑŸäÿ©\n`/admin_forcejoin` - ÿ•ÿ¨ÿ®ÿßÿ± ÿßŸÑÿ®Ÿàÿ™ ÿπŸÑŸâ ÿßŸÑÿØÿÆŸàŸÑ',
                inline: false
            });
        }
        
        await interaction.reply({ embeds: [embed], ephemeral: true });
    }

    async handlePlayCommand(interaction) {
        await interaction.deferReply();
        
        const query = interaction.options.getString('query');
        const member = interaction.member;
        
        if (!member.voice.channel) {
            const embed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå ÿÆÿ∑ÿ£')
                .setDescription('Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÅŸä ÿ∫ÿ±ŸÅÿ© ÿµŸàÿ™Ÿäÿ© ŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ!')
                .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
            
            await interaction.editReply({ embeds: [embed] });
            return;
        }
        
        try {
            const musicPlayer = this.getMusicPlayer(interaction.guildId);
            
            // Join voice channel if not connected
            if (!musicPlayer.connection) {
                await this.connectToVoice(member.voice.channel, musicPlayer);
            }
            
            // Search for song
            let songUrl = query;
            let songInfo;
            
            if (!ytdl.validateURL(query)) {
                const searchResults = await YouTubeSearchAPI.GetListByKeyword(query, false, 1);
                if (searchResults.items.length === 0) {
                    throw new Error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÜÿ™ÿßÿ¶ÿ¨');
                }
                songUrl = `https://www.youtube.com/watch?v=${searchResults.items[0].id}`;
            }
            
            // Get song info
            songInfo = await ytdl.getInfo(songUrl);
            
            const song = {
                title: songInfo.videoDetails.title,
                url: songUrl,
                duration: songInfo.videoDetails.lengthSeconds,
                requester: interaction.user,
                thumbnail: songInfo.videoDetails.thumbnails[0]?.url
            };
            
            musicPlayer.queue.push(song);
            
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ£ÿ∫ŸÜŸäÿ©')
                .setDescription(`**${song.title}**`)
                .addFields(
                    { name: 'ÿßŸÑŸÖÿØÿ©', value: this.formatDuration(song.duration), inline: true },
                    { name: 'ÿßŸÑŸÖŸàÿ∂ÿπ ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©', value: `${musicPlayer.queue.length}`, inline: true },
                    { name: 'ÿ∑ÿßŸÑÿ® ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ', value: interaction.user.toString(), inline: true }
                )
                .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
            
            if (song.thumbnail) {
                embed.setThumbnail(song.thumbnail);
            }
            
            await interaction.editReply({ embeds: [embed] });
            
            // Start playing if not already playing
            if (!musicPlayer.isPlaying) {
                await this.playNext(musicPlayer);
            }
            
        } catch (error) {
            console.error('Play command error:', error);
            
            const embed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå ÿÆÿ∑ÿ£')
                .setDescription('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ£ÿ∫ŸÜŸäÿ©. ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ£Ÿà ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.')
                .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
            
            await interaction.editReply({ embeds: [embed] });
        }
    }

    async connectToVoice(voiceChannel, musicPlayer) {
        try {
            const connection = joinVoiceChannel({
                channelId: voiceChannel.id,
                guildId: voiceChannel.guild.id,
                adapterCreator: voiceChannel.guild.voiceAdapterCreator,
            });
            
            connection.on(VoiceConnectionStatus.Ready, () => {
                console.log(`üéµ Bot #${this.botNumber} connected to voice channel: ${voiceChannel.name}`);
            });
            
            connection.on(VoiceConnectionStatus.Disconnected, () => {
                console.log(`üîå Bot #${this.botNumber} disconnected from voice`);
                // Auto-reconnect logic can be added here
            });
            
            connection.subscribe(musicPlayer.player);
            musicPlayer.connection = connection;
            musicPlayer.channel = voiceChannel;
            
            // Keep-alive mechanism
            this.startKeepAlive(musicPlayer);
            
        } catch (error) {
            console.error('Voice connection error:', error);
            throw error;
        }
    }

    async playNext(musicPlayer) {
        if (musicPlayer.queue.length === 0) {
            musicPlayer.isPlaying = false;
            musicPlayer.currentSong = null;
            console.log(`üéµ Bot #${this.botNumber}: Queue empty, staying connected`);
            return;
        }
        
        const song = musicPlayer.queue.shift();
        musicPlayer.currentSong = song;
        musicPlayer.isPlaying = true;
        
        try {
            const stream = ytdl(song.url, {
                filter: 'audioonly',
                quality: 'highestaudio',
                highWaterMark: 1 << 25
            });
            
            const resource = createAudioResource(stream, {
                inputType: 'webm/opus'
            });
            
            musicPlayer.player.play(resource);
            
            musicPlayer.player.once(AudioPlayerStatus.Playing, () => {
                console.log(`‚ñ∂Ô∏è Bot #${this.botNumber} now playing: ${song.title}`);
            });
            
            musicPlayer.player.once(AudioPlayerStatus.Idle, () => {
                this.playNext(musicPlayer);
            });
            
        } catch (error) {
            console.error('Playback error:', error);
            musicPlayer.isPlaying = false;
            await this.playNext(musicPlayer);
        }
    }

    startKeepAlive(musicPlayer) {
        if (musicPlayer.keepAliveInterval) return;
        
        musicPlayer.keepAliveInterval = setInterval(() => {
            if (!musicPlayer.connection || musicPlayer.connection.state.status === VoiceConnectionStatus.Destroyed) {
                clearInterval(musicPlayer.keepAliveInterval);
                musicPlayer.keepAliveInterval = null;
                return;
            }
            
            // Keep connection alive - no action needed, just checking
            console.log(`üíì Bot #${this.botNumber}: Keep-alive check`);
        }, 30000); // Every 30 seconds
    }

    formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = seconds % 60;
        
        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        } else {
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
    }

    async handleJoinRoomCommand(interaction) {
        const channelName = interaction.options.getString('channel_name');
        const voiceChannel = interaction.guild.channels.cache
            .filter(ch => ch.type === 2) // Voice channels
            .find(ch => ch.name.toLowerCase().includes(channelName.toLowerCase()));
        
        if (!voiceChannel) {
            const availableChannels = interaction.guild.channels.cache
                .filter(ch => ch.type === 2)
                .map(ch => ch.name)
                .slice(0, 5)
                .join(', ');
            
            const embed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿ∫ÿ±ŸÅÿ©')
                .setDescription(`ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©: ${availableChannels}`)
                .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
            
            await interaction.reply({ embeds: [embed], ephemeral: true });
            return;
        }
        
        try {
            const musicPlayer = this.getMusicPlayer(interaction.guildId);
            await this.connectToVoice(voiceChannel, musicPlayer);
            
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üéµ ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©')
                .setDescription(`ŸÖÿ™ÿµŸÑ ÿ®ŸÄ: **${voiceChannel.name}**`)
                .addFields(
                    { name: 'ÿßŸÑÿ£ÿπÿ∂ÿßÿ°', value: `${voiceChannel.members.size} ÿ¥ÿÆÿµ`, inline: true },
                    { name: 'ÿ±ŸÇŸÖ ÿßŸÑÿ®Ÿàÿ™', value: `#${this.botNumber}`, inline: true },
                    { name: 'Ÿàÿ∂ÿπ 24/7', value: '‚úÖ ÿ≥Ÿäÿ®ŸÇŸâ ŸÖÿ™ÿµŸÑ', inline: true }
                )
                .setFooter({ text: 'ÿßŸÑÿ®Ÿàÿ™ ÿ≥Ÿäÿ®ŸÇŸâ ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ≠ÿ™Ÿâ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ /leave!' });
            
            await interaction.reply({ embeds: [embed] });
        } catch (error) {
            console.error('Join room error:', error);
            
            const embed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå ŸÅÿ¥ŸÑ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ')
                .setDescription('ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©.')
                .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
            
            await interaction.reply({ embeds: [embed], ephemeral: true });
        }
    }

    async handleLeaveCommand(interaction) {
        const musicPlayer = this.musicPlayers.get(interaction.guildId);
        
        if (!musicPlayer || !musicPlayer.connection) {
            await interaction.reply({
                content: '‚ùå ŸÑÿ≥ÿ™ ŸÖÿ™ÿµŸÑ ÿ®ÿ£Ÿä ÿ∫ÿ±ŸÅÿ© ÿµŸàÿ™Ÿäÿ©!',
                ephemeral: true
            });
            return;
        }
        
        const channelName = musicPlayer.channel?.name || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ';
        
        // Stop music and clear queue
        musicPlayer.queue = [];
        musicPlayer.currentSong = null;
        musicPlayer.isPlaying = false;
        
        // Clear keep-alive
        if (musicPlayer.keepAliveInterval) {
            clearInterval(musicPlayer.keepAliveInterval);
            musicPlayer.keepAliveInterval = null;
        }
        
        // Disconnect
        musicPlayer.connection.destroy();
        musicPlayer.connection = null;
        
        const embed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('üëã ÿ™ŸÖ ŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ')
            .setDescription(`ÿ∫ÿßÿØÿ±ÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©: **${channelName}**\n\n**ÿßÿ≥ÿ™ÿÆÿØŸÖ \`/joinroom\` ŸÑŸÑÿßÿ™ÿµÿßŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ**`)
            .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} ‚Ä¢ ŸäÿÆÿ±ÿ¨ ŸÅŸÇÿ∑ ÿπŸÜÿØŸÖÿß ÿ™ÿ∑ŸÑÿ® ÿ∞ŸÑŸÉ!` });
        
        await interaction.reply({ embeds: [embed] });
    }

    // Add other command handlers...
    async handleListRoomsCommand(interaction) {
        const voiceChannels = interaction.guild.channels.cache
            .filter(ch => ch.type === 2)
            .sort((a, b) => a.position - b.position)
            .first(10);
        
        if (voiceChannels.size === 0) {
            await interaction.reply({
                content: '‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ∫ÿ±ŸÅ ÿµŸàÿ™Ÿäÿ© ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±!',
                ephemeral: true
            });
            return;
        }
        
        const embed = new EmbedBuilder()
            .setColor('#0099FF')
            .setTitle('üéôÔ∏è ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿµŸàÿ™Ÿäÿ© ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©')
            .setDescription('ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿµŸàÿ™Ÿäÿ© ŸÅŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:')
            .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} ‚Ä¢ ÿßÿ≥ÿ™ÿÆÿØŸÖ /joinroom [ÿßÿ≥ŸÖ_ÿßŸÑÿ∫ÿ±ŸÅÿ©] ŸÑŸÑÿßŸÜÿ∂ŸÖÿßŸÖ` });
        
        voiceChannels.forEach(channel => {
            const memberCount = channel.members.size;
            const status = `üë• ${memberCount} ÿ£ÿπÿ∂ÿßÿ°`;
            embed.addFields({ name: channel.name, value: status, inline: true });
        });
        
        await interaction.reply({ embeds: [embed] });
    }

    async handleBotInfoCommand(interaction) {
        const embed = new EmbedBuilder()
            .setColor('#9932CC')
            .setTitle(`ü§ñ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}`)
            .setDescription('ŸÜÿ∏ÿßŸÖ ŸÖŸàÿ≥ŸäŸÇŸâ Discord ŸÖÿ™ŸÇÿØŸÖ')
            .addFields(
                { name: 'ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™', value: this.client.user.tag, inline: true },
                { name: 'ÿ±ŸÇŸÖ ÿßŸÑÿ®Ÿàÿ™', value: `#${this.botNumber}`, inline: true },
                { name: 'Ping', value: `${this.client.ws.ping}ms`, inline: true },
                { name: 'ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™', value: `${this.client.guilds.cache.size}`, inline: true },
                { name: 'Ÿàÿ∂ÿπ 24/7', value: '‚úÖ ŸÜÿ¥ÿ∑', inline: true },
                { name: 'ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ®Ÿàÿ™ÿßÿ™', value: '16 ÿ®Ÿàÿ™', inline: true }
            )
            .setThumbnail(this.client.user.displayAvatarURL())
            .setFooter({ text: 'ŸÜÿ∏ÿßŸÖ 16-Bot ŸÑŸÑŸÖŸàÿ≥ŸäŸÇŸâ ‚Ä¢ ŸäÿπŸÖŸÑ 24/7' })
            .setTimestamp();
        
        await interaction.reply({ embeds: [embed] });
    }

    // Add pause, resume, skip, stop, queue, nowplaying, volume handlers...
    async handlePauseCommand(interaction) {
        const musicPlayer = this.musicPlayers.get(interaction.guildId);
        
        if (!musicPlayer || !musicPlayer.isPlaying) {
            await interaction.reply({
                content: '‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸàÿ≥ŸäŸÇŸâ ŸÇŸäÿØ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ!',
                ephemeral: true
            });
            return;
        }
        
        musicPlayer.player.pause();
        
        const embed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚è∏Ô∏è ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÖÿ§ŸÇÿ™ÿßŸã')
            .setDescription('ÿßÿ≥ÿ™ÿÆÿØŸÖ `/resume` ŸÑŸÖÿ™ÿßÿ®ÿπÿ© ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ')
            .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
        
        await interaction.reply({ embeds: [embed] });
    }

    async handleResumeCommand(interaction) {
        const musicPlayer = this.musicPlayers.get(interaction.guildId);
        
        if (!musicPlayer) {
            await interaction.reply({
                content: '‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸàÿ≥ŸäŸÇŸâ ŸÖÿ™ŸàŸÇŸÅÿ©!',
                ephemeral: true
            });
            return;
        }
        
        musicPlayer.player.unpause();
        
        const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚ñ∂Ô∏è ÿ™ŸÖ ÿßÿ≥ÿ™ŸÉŸÖÿßŸÑ ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ')
            .setDescription('ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ÿ™ÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ')
            .setFooter({ text: `ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber}` });
        
        await interaction.reply({ embeds: [embed] });
    }

    async handleAdminBotListCommand(interaction) {
        if (!interaction.memberPermissions?.has('Administrator')) {
            await interaction.reply({
                content: '‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± Ÿäÿ™ÿ∑ŸÑÿ® ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±ÿ©!',
                ephemeral: true
            });
            return;
        }
        
        const embed = new EmbedBuilder()
            .setColor('#FFD700')
            .setTitle('ü§ñ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ®Ÿàÿ™ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©')
            .setDescription('ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ© ŸÅŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±')
            .setFooter({ text: 'ŸÜÿ∏ÿßŸÖ 16-Bot ‚Ä¢ ÿ®ŸäÿßŸÜÿßÿ™ ÿ≠Ÿäÿ©' });
        
        // Get all bot members
        const botMembers = interaction.guild.members.cache.filter(member => 
            member.user.bot && (member.user.username.includes('support') || member.user.username.includes('DEVIL'))
        );
        
        if (botMembers.size > 0) {
            botMembers.forEach(bot => {
                const status = bot.presence?.status === 'offline' ? 'üî¥ ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ' : 'üü¢ ŸÖÿ™ÿµŸÑ';
                const voiceStatus = bot.voice.channel ? `ŸÅŸä: ${bot.voice.channel.name}` : 'ŸÑŸäÿ≥ ŸÅŸä ÿ∫ÿ±ŸÅÿ© ÿµŸàÿ™Ÿäÿ©';
                
                embed.addFields({
                    name: bot.user.username,
                    value: `${status}\n${voiceStatus}`,
                    inline: true
                });
            });
        } else {
            embed.setDescription('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ®Ÿàÿ™ÿßÿ™ ŸÖŸàÿ≥ŸäŸÇŸâ ŸÅŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±');
        }
        
        await interaction.reply({ embeds: [embed] });
    }

    async handleAdminStatusCommand(interaction) {
        if (!interaction.memberPermissions?.has('Administrator')) {
            await interaction.reply({
                content: '‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± Ÿäÿ™ÿ∑ŸÑÿ® ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±ÿ©!',
                ephemeral: true
            });
            return;
        }
        
        const musicPlayer = this.musicPlayers.get(interaction.guildId);
        
        const embed = new EmbedBuilder()
            .setColor('#FF8C00')
            .setTitle(`üîß ÿ≠ÿßŸÑÿ© ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} - ŸÑŸÑÿ•ÿØÿßÿ±ÿ©`)
            .addFields(
                { name: 'ÿßÿ≥ŸÖ ÿßŸÑÿ®Ÿàÿ™', value: this.client.user.tag, inline: true },
                { name: 'ÿ±ŸÇŸÖ ÿßŸÑÿ®Ÿàÿ™', value: `#${this.botNumber}`, inline: true },
                { name: 'Ping', value: `${this.client.ws.ping}ms`, inline: true }
            );
        
        if (musicPlayer && musicPlayer.connection) {
            embed.addFields(
                { name: 'ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©', value: musicPlayer.channel?.name || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ', inline: true },
                { name: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸàÿ™', value: 'üü¢ ŸÖÿ™ÿµŸÑ', inline: true }
            );
        } else {
            embed.addFields({ name: 'ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸàÿ™', value: 'üî¥ ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ', inline: true });
        }
        
        if (musicPlayer?.currentSong) {
            embed.addFields({
                name: 'ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©',
                value: musicPlayer.currentSong.title.substring(0, 50),
                inline: false
            });
        }
        
        const queueSize = musicPlayer?.queue?.length || 0;
        embed.addFields({ name: 'ÿ≠ÿ¨ŸÖ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©', value: `${queueSize} ÿ£ÿ∫ŸÜŸäÿ©`, inline: true });
        
        await interaction.reply({ embeds: [embed] });
    }

    async handleAdminForceJoinCommand(interaction) {
        if (!interaction.memberPermissions?.has('Administrator')) {
            await interaction.reply({
                content: '‚ùå Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± Ÿäÿ™ÿ∑ŸÑÿ® ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±ÿ©!',
                ephemeral: true
            });
            return;
        }
        
        const channelName = interaction.options.getString('channel_name');
        const voiceChannel = interaction.guild.channels.cache
            .filter(ch => ch.type === 2)
            .find(ch => ch.name.toLowerCase().includes(channelName.toLowerCase()));
        
        if (!voiceChannel) {
            const availableChannels = interaction.guild.channels.cache
                .filter(ch => ch.type === 2)
                .map(ch => ch.name)
                .slice(0, 5)
                .join(', ');
            
            await interaction.reply({
                content: `‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿ∫ÿ±ŸÅÿ© '${channelName}'!\nÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©: ${availableChannels}`,
                ephemeral: true
            });
            return;
        }
        
        try {
            const musicPlayer = this.getMusicPlayer(interaction.guildId);
            await this.connectToVoice(voiceChannel, musicPlayer);
            
            await interaction.reply({
                content: `‚úÖ ÿßŸÑÿ®Ÿàÿ™ #${this.botNumber} ÿßŸÜÿ∂ŸÖ ÿ•ÿ¨ÿ®ÿßÿ±ŸäÿßŸã ÿ•ŸÑŸâ: **${voiceChannel.name}**`
            });
        } catch (error) {
            console.error('Force join error:', error);
            await interaction.reply({
                content: `‚ùå ŸÅÿ¥ŸÑ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ: ${error.message}`,
                ephemeral: true
            });
        }
    }

    async start(token) {
        try {
            await this.client.login(token);
        } catch (error) {
            console.error(`‚ùå Failed to start Bot #${this.botNumber}:`, error);
            throw error;
        }
    }
}

module.exports = MusicBot;
